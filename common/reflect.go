package common

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"path/filepath"
	"reflect"
	"regexp"
	"runtime"
	"strings"
)

// ReflectFunctionName returns the fully-qualifed name of a function.
// eg. "github.com/rotblauer/geom.(*Polygon).Area"
// eg. "github.com/rotblauer/geom.(*Polygon).Length"
// eg. "github.com/sams96/rgeo.Countries110
func ReflectFunctionName(i interface{}) string {
	return runtimeFunc(i).Name()
}

func runtimeFunc(i interface{}) *runtime.Func {
	return runtime.FuncForPC(reflect.ValueOf(i).Pointer())
}

//func ReflectMethodName(receiver, m interface{}) string {
//	ty := reflect.TypeOf(receiver)
//	//rval := reflect.ValueOf(receiver)
//	//fnName := runtimeFuncBaseName()
//
//	for i := 0; i < ty.NumMethod(); i++ {
//		method := ty.Method(i)
//		mp := method.Func.Pointer()
//
//		log.Println(mp, fp)
//		if mp == fp {
//			return method.Name
//		}
//	}
//	return ""
//}

func runtimeFuncBaseName(rf *runtime.Func) string {
	spl := strings.Split(rf.Name(), ".")
	return spl[len(spl)-1]
}

func isExportedMethod(method reflect.Method) bool {
	return method.PkgPath == ""
}

func isExportedOrBuiltinType(t reflect.Type) bool {
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	// PkgPath will be non-empty even for an exported type,
	// so we need to check the type name as well.
	return token.IsExported(t.Name()) || t.PkgPath() == ""
}

var errAutogenerated = errors.New("autogenerated file")
var errInvalidFilepath = errors.New("invalid filepath")

func getAstFuncDecl(r reflect.Value, m reflect.Method) (*ast.FuncDecl, error) {
	runtimeFunc := runtime.FuncForPC(m.Func.Pointer())
	runtimeFile, _ := runtimeFunc.FileLine(runtimeFunc.Entry())

	if strings.Contains(runtimeFile, "autogenerated") {
		return nil, errAutogenerated
	}

	tokenFileSet := token.NewFileSet()
	if !filepath.IsAbs(runtimeFile) {
		return nil, fmt.Errorf("%w: %s", errInvalidFilepath, runtimeFile)
	}

	astFile, err := parser.ParseFile(tokenFileSet, runtimeFile, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parse file: %w, method: %s, file: %s", err, m.Name, runtimeFile)
	}

	rfName := runtimeFuncBaseName(runtimeFunc)

	for _, decl := range astFile.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}
		if fn.Name == nil || fn.Name.Name != rfName {
			continue
		}

		fnRecName := ""
		if fn.Recv != nil && fn.Recv.List != nil && len(fn.Recv.List) > 0 {
			for _, l := range fn.Recv.List {
				if fnRecName != "" {
					break
				}

				i, ok := l.Type.(*ast.Ident)
				if ok {
					fnRecName = i.Name
					continue
				}
				s, ok := l.Type.(*ast.StarExpr)
				if ok {
					fnRecName = fmt.Sprintf("%v", s.X)
				}
			}
		}

		// Ensure that the receiver name matches.
		reRec := regexp.MustCompile(fnRecName + `\s`)
		if !reRec.MatchString(r.String()) {
			continue
		}
		return fn, nil
	}
	return nil, nil
}
